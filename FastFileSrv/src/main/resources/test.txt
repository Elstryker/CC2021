Instead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more comments
Instead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");
Instead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more comments

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more comments
Instead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more comments
Instead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more comments
Instead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more commentsInstead of reading the entire thing to a buffer and then writing it all out at once in encrypted form, you can use streams to read and write chunks at a time. Specifically, you could use a CipherOutputStream to encrypt as you go.

Just as an example of the kind of thing you might do:

byte[] buffer = new byte[4096];
FileInputStream fileInStream = new FileInputStream("in.txt");
FileOutputStream fileStream = new FileOutputStream("test.bin");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
CipherOutputStream cipherStream = new CipherOutputStream(fileStream, cipher);

while(fileInStream.read(buffer) > 0){
    cipherStream.write(buffer);
}
If you are just trying to reverse the entire file without reading the whole thing into memory all at once, you could do something like this, noting that you'll need to reference Commons.Lang in order to get the ArrayUtils.reverse functionality:

byte[] buffer = new byte[4096];
File file = new File("in.txt");
FileInputStream fileInput = new FileInputStream(file);
FileOutputStream fileOutput = new FileOutputStream("out.bin");

int index = (int)(file.length() - 4096);
int bytesRead = -1;
while((bytesRead = fileInput.read(buffer, index, 4096)) > 0 && index >= 0){
    index = Math.max(index - 4096, 0);
    if(bytesRead < 4096){
        buffer = Arrays.copyOf(buffer, bytesRead);
    }
    ArrayUtils.reverse(buffer);
    fileOutput.write(buffer);
}
Share
Improve this answer
Follow
edited May 5 '17 at 10:58
answered May 5 '17 at 8:22

jropella
56855 silver badges1414 bronze badges
Let's assume that instead of encryption, I have to reverse the byte array. So will using stream be a way to go? – hhj8i May 5 '17 at 8:25
In that case you might consider implementing your own extension of a stream reader/writer which simply reverses the array of bytes. This way you're still dealing with chunks from the consuming side. – jropella May 5 '17 at 8:26 
@jropella reversing only bytes within chunks rather than entire file... So if file was 12345678 and chunk was of size 2, then you would get 21436587. Reversing entire file would require reading the original and writing to new file if space permits, otherwise you are looking at random access file and reversing byte at the time (it will cost time). – diginoise May 5 '17 at 8:35 
1
@diginoise: what about reading it backwards? Start at index = size, read from index to index - x until index = 0, reversing as you go. – jropella May 5 '17 at 8:36
@jropella exactly. as I mentioned to do it 'in place' it will take long time (maybe not prohibitively long) compared to reading original and writing to new file. – diginoise May 5 '17 at 8:40
Show 2 more comments